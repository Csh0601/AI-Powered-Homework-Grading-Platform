
● 🎯 校园网自动发现服务器 - 解决方案计划

  一、问题分析

  ✅ 后端状态（已解决）

  - run.py:183 已配置 host='0.0.0.0', port=5000
  - 后端监听所有网络接口，任何IP都可访问
  - 无需修改后端

  ❌ 前端问题（需要解决）

  1. IP硬编码问题 (api.ts:95-106)

  const NETWORK_PRESETS = [
    'http://172.28.140.34:5000',     // 历史IP，可能已失效
    'http://172.29.15.82:5000',      // 固定IP，不同用户无法使用
    'http://172.19.168.76:5000',     // ...
    // 更多硬编码IP
  ];

  2. 现有检测机制的局限

  - resolveBaseUrl() (apiService.ts:41) 只遍历预设IP列表
  - 遍历耗时长（每个IP 15秒超时）
  - 用户在新IP段时完全无法连接

  3. 用户痛点

  - 每次校园网IP变化都需要修改代码
  - 不同用户需要各自配置
  - 无法做到"即插即用"

  ---
  二、解决方案设计

  🎯 核心目标

  让任何用户在校园网内，不论IP地址，都能自动发现并连接到服务器

  📋 解决方案：多层次智能发现机制

  方案架构图

  前端启动
      ↓
  [1] 检查缓存的成功IP ✅
      ↓ 失败
  [2] 智能校园网段扫描 ⚡ (主要方案)
      ↓ 失败
  [3] UDP广播服务发现 📡 (备选方案)
      ↓ 失败
  [4] 手动输入IP 🔧 (兜底方案)

  ---
  三、详细实现计划

  🚀 方案1：智能校园网段扫描 (推荐，主要实现)

  原理：

  - 深圳大学校园网IP段：172.16.0.0/12 (172.16.0.0 - 172.31.255.255)
  - 获取设备当前IP，智能推断服务器可能所在网段
  - 并行快速扫描该网段，找到后端服务器

  前端修改（api.ts）：

  新增功能：
  1. 获取设备当前IP地址
  const getCurrentDeviceIP = async () => {
    // 从Expo Constants或网络接口获取
    // 返回类似 "172.28.140.25"
  }
  2. 生成智能扫描列表
  const generateSmartScanList = (deviceIP: string) => {
    // 如果设备IP是 172.28.140.25
    // 生成扫描列表：
    // - 172.28.140.x (同C段，优先)
    // - 172.28.x.x (同B段)
    // - 172.x.x.x (同A段)
    // - 常见网关：172.28.140.1, 172.28.0.1等
  }
  3. 并行快速扫描
  const parallelScan = async (candidates: string[]) => {
    // 同时检测多个IP（如10个并发）
    // 使用短超时（3秒）
    // 第一个响应的立即返回
  }
  4. 成功IP缓存
  // 使用 AsyncStorage 缓存最近成功的IP
  // 下次启动优先尝试

  实现文件清单：

  llmhomework_Frontend/app/config/
    ├── api.ts (修改)
    └── serverDiscovery.ts (新增)

  llmhomework_Frontend/app/services/
    ├── apiService.ts (修改)
    └── networkScanner.ts (新增)

  ---
  📡 方案2：UDP广播服务发现 (备选，可选实现)

  原理：

  - 后端启动时在局域网内定期广播自己的IP
  - 前端监听广播，自动获取后端IP

  后端修改：

  新增文件： llmhomework_Backend/app/services/discovery_broadcast.py
  import socket
  import json
  import threading
  import time

  class ServiceBroadcaster:
      def __init__(self, port=5000, broadcast_port=37020):
          self.port = port
          self.broadcast_port = broadcast_port

      def start(self):
          # 每5秒广播一次服务器信息
          def broadcast_loop():
              sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
              sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)

              while True:
                  message = json.dumps({
                      'service': 'llm-homework-backend',
                      'port': self.port,
                      'ip': get_local_ip()
                  })
                  sock.sendto(message.encode(), ('<broadcast>', self.broadcast_port))
                  time.sleep(5)

          thread = threading.Thread(target=broadcast_loop, daemon=True)
          thread.start()

  在run.py中启动：
  # run.py 添加
  from app.services.discovery_broadcast import ServiceBroadcaster

  if __name__ == '__main__':
      # 启动服务发现广播
      broadcaster = ServiceBroadcaster()
      broadcaster.start()

      app.run(host='0.0.0.0', port=5000, debug=True, threaded=True)

  前端修改：

  新增文件： llmhomework_Frontend/app/services/udpDiscovery.ts
  // React Native UDP 库监听广播
  import dgram from 'react-native-udp';

  export const discoverServerViaUDP = async (timeout = 10000) => {
    return new Promise((resolve, reject) => {
      const socket = dgram.createSocket('udp4');

      socket.on('message', (msg, rinfo) => {
        const data = JSON.parse(msg.toString());
        if (data.service === 'llm-homework-backend') {
          resolve(`http://${rinfo.address}:${data.port}`);
          socket.close();
        }
      });

      socket.bind(37020);

      setTimeout(() => {
        socket.close();
        reject(new Error('UDP discovery timeout'));
      }, timeout);
    });
  };

  ---
  🔧 方案3：二维码配置 (用户友好，强烈推荐)

  原理：

  - 后端启动时生成包含IP的二维码
  - 前端扫描二维码自动配置

  后端修改：

  安装依赖：
  pip install qrcode pillow

  新增功能： llmhomework_Backend/app/routes/qr_config.py
  from flask import Blueprint, send_file
  import qrcode
  import io
  import socket

  qr_bp = Blueprint('qr_config', __name__)

  @qr_bp.route('/config/qr', methods=['GET'])
  def get_config_qr():
      """生成配置二维码"""
      # 获取本机IP
      local_ip = socket.gethostbyname(socket.gethostname())

      # 或者更准确的IP获取
      s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
      s.connect(("8.8.8.8", 80))
      local_ip = s.getsockname()[0]
      s.close()

      # 生成配置URL
      config_url = f"http://{local_ip}:5000"

      # 生成二维码
      qr = qrcode.QRCode(version=1, box_size=10, border=5)
      qr.add_data(config_url)
      qr.make(fit=True)

      img = qr.make_image(fill_color="black", back_color="white")

      # 返回图片
      img_io = io.BytesIO()
      img.save(img_io, 'PNG')
      img_io.seek(0)

      return send_file(img_io, mimetype='image/png')

  在run.py启动时显示：
  def print_startup_banner():
      # ... 现有代码 ...

      # 生成二维码到控制台（ASCII艺术）
      import qrcode
      local_ip = get_local_ip()
      config_url = f"http://{local_ip}:5000"

      qr = qrcode.QRCode()
      qr.add_data(config_url)
      qr.make()
      qr.print_ascii()  # 在控制台打印ASCII二维码

      print(f"\n📱 扫描二维码配置前端: {config_url}\n")

  前端修改：

  新增屏幕： llmhomework_Frontend/app/screens/QRScannerScreen.tsx
  import { BarCodeScanner } from 'expo-barcode-scanner';

  export const QRScannerScreen = () => {
    const handleBarCodeScanned = ({ data }) => {
      // data = "http://172.28.140.34:5000"
      // 保存到 AsyncStorage
      AsyncStorage.setItem('backend_url', data);
      // 更新全局配置
      updateApiConfig(data);
    };

    return <BarCodeScanner onBarCodeScanned={handleBarCodeScanned} />;
  };

  ---
  💾 方案4：成功IP持久化缓存

  实现：

  // llmhomework_Frontend/app/services/ipCache.ts

  import AsyncStorage from '@react-native-async-storage/async-storage';

  export const IPCache = {
    // 保存成功的IP
    async save(ip: string) {
      const history = await this.getHistory();
      history.unshift({
        ip,
        timestamp: Date.now(),
        success: true
      });
      // 只保留最近10个
      await AsyncStorage.setItem('ip_history', JSON.stringify(history.slice(0, 10)));
    },

    // 获取历史记录
    async getHistory() {
      const data = await AsyncStorage.getItem('ip_history');
      return data ? JSON.parse(data) : [];
    },

    // 获取最近成功的IP（按时间排序）
    async getRecentSuccessful() {
      const history = await this.getHistory();
      return history
        .filter(item => item.success)
        .sort((a, b) => b.timestamp - a.timestamp)
        .map(item => item.ip);
    }
  };

  ---
  四、完整实现计划（优先级排序）

  🎯 阶段1：核心功能 (必须实现)

  1.1 智能校园网段扫描

  - 文件： llmhomework_Frontend/app/services/networkScanner.ts
    - 获取设备IP
    - 生成智能扫描列表
    - 并行快速扫描
    - 返回第一个可用IP

  1.2 IP缓存机制

  - 文件： llmhomework_Frontend/app/services/ipCache.ts
    - 保存成功IP到AsyncStorage
    - 下次启动优先尝试缓存IP

  1.3 修改API配置

  - 文件： llmhomework_Frontend/app/config/api.ts
    - 移除硬编码IP列表
    - 集成智能扫描
    - 优先使用缓存IP

  1.4 修改API服务

  - 文件： llmhomework_Frontend/app/services/apiService.ts
    - 在上传前自动发现服务器
    - 失败时触发重新扫描

  ---
  ⭐ 阶段2：用户体验优化 (强烈推荐)

  2.1 二维码配置

  - 后端： llmhomework_Backend/app/routes/qr_config.py
    - 生成配置二维码接口
    - 在启动横幅显示ASCII二维码
  - 前端： llmhomework_Frontend/app/screens/QRScannerScreen.tsx
    - 二维码扫描功能
    - 自动配置后端地址

  2.2 手动配置界面

  - 前端： llmhomework_Frontend/app/screens/SettingsScreen.tsx
    - 添加"手动输入服务器地址"选项
    - 显示当前连接状态
    - 显示IP历史记录

  2.3 连接状态指示

  - 前端： 在主界面添加网络状态指示器
    - 显示当前连接的服务器IP
    - 显示连接质量（延迟）
    - 一键重新扫描按钮

  ---
  🔬 阶段3：高级功能 (可选)

  3.1 UDP广播发现

  - 后端： llmhomework_Backend/app/services/discovery_broadcast.py
  - 前端： llmhomework_Frontend/app/services/udpDiscovery.ts
  - 依赖： npm install react-native-udp

  3.2 多服务器支持

  - 支持同时发现多个后端服务器
  - 自动选择延迟最低的服务器
  - 负载均衡

  ---
  五、核心代码实现预览

  📝 核心代码1：智能网段扫描

  // llmhomework_Frontend/app/services/networkScanner.ts

  import { Platform } from 'react-native';
  import NetInfo from '@react-native-community/netinfo';

  export class NetworkScanner {
    private readonly BACKEND_PORT = 5000;
    private readonly SCAN_TIMEOUT = 3000;  // 单个IP扫描超时3秒
    private readonly PARALLEL_SCANS = 10;   // 同时扫描10个IP

    /**
     * 获取设备当前IP地址
     */
    async getCurrentDeviceIP(): Promise<string | null> {
      try {
        const netInfo = await NetInfo.fetch();
        // React Native NetInfo 可能需要原生模块支持
        // 备选方案：从Expo Constants获取
        return netInfo.details?.ipAddress || null;
      } catch (error) {
        console.error('获取设备IP失败:', error);
        return null;
      }
    }

    /**
     * 根据设备IP生成智能扫描列表
     */
    generateSmartScanList(deviceIP: string): string[] {
      const candidates: string[] = [];

      // 解析IP (例如: 172.28.140.25)
      const parts = deviceIP.split('.');
      if (parts.length !== 4) return [];

      const [a, b, c, d] = parts;

      // 1. 同C段扫描 (172.28.140.x) - 最优先
      // 优先扫描常见服务器IP
      const commonHosts = [1, 2, 10, 100, 254];  // 常见网关/服务器IP
      for (const host of commonHosts) {
        candidates.push(`http://${a}.${b}.${c}.${host}:${this.BACKEND_PORT}`);
      }

      // 扫描邻近IP
      const currentHost = parseInt(d);
      for (let offset = 1; offset <= 20; offset++) {
        const host1 = currentHost - offset;
        const host2 = currentHost + offset;
        if (host1 > 0) candidates.push(`http://${a}.${b}.${c}.${host1}:${this.BACKEND_PORT}`);
        if (host2 < 255) candidates.push(`http://${a}.${b}.${c}.${host2}:${this.BACKEND_PORT}`);
      }

      // 2. 同B段不同C段 (172.28.x.1)
      for (let c_new = 0; c_new < 256; c_new += 10) {
        if (c_new.toString() !== c) {
          candidates.push(`http://${a}.${b}.${c_new}.1:${this.BACKEND_PORT}`);
        }
      }

      // 3. 校园网其他常见段 (172.16-31.x.x)
      for (let b_new = 16; b_new <= 31; b_new++) {
        if (b_new.toString() !== b) {
          candidates.push(`http://${a}.${b_new}.0.1:${this.BACKEND_PORT}`);
        }
      }

      // 去重
      return Array.from(new Set(candidates));
    }

    /**
     * 并行快速扫描
     */
    async parallelScan(candidates: string[]): Promise<string | null> {
      console.log(`🔍 开始并行扫描 ${candidates.length} 个候选地址...`);

      // 分批并行扫描
      for (let i = 0; i < candidates.length; i += this.PARALLEL_SCANS) {
        const batch = candidates.slice(i, i + this.PARALLEL_SCANS);
        console.log(`📡 扫描批次 ${Math.floor(i / this.PARALLEL_SCANS) + 1}: ${batch.length} 个地址`);

        const result = await this.scanBatch(batch);
        if (result) {
          console.log(`✅ 找到服务器: ${result}`);
          return result;
        }
      }

      console.log('❌ 所有候选地址扫描完毕，未找到服务器');
      return null;
    }

    /**
     * 扫描一批IP
     */
    private async scanBatch(urls: string[]): Promise<string | null> {
      const promises = urls.map(url => this.checkServer(url));

      // 使用 Promise.race 返回第一个成功的
      try {
        const result = await Promise.race(
          promises.map(p => p.then(url => ({ success: true, url })))
        );
        if (result.success) {
          return result.url;
        }
      } catch (error) {
        // 所有都失败
      }

      return null;
    }

    /**
     * 检查单个服务器
     */
    private async checkServer(url: string): Promise<string | null> {
      try {
        const controller = new AbortController();
        const timeout = setTimeout(() => controller.abort(), this.SCAN_TIMEOUT);

        const response = await fetch(`${url}/status`, {
          method: 'GET',
          signal: controller.signal,
          headers: {
            'Cache-Control': 'no-cache',
          },
        });

        clearTimeout(timeout);

        if (response.ok) {
          console.log(`✅ 服务器响应: ${url}`);
          return url;
        }
      } catch (error) {
        // 静默失败，继续下一个
      }

      return null;
    }

    /**
     * 主入口：智能发现服务器
     */
    async discoverServer(): Promise<string | null> {
      console.log('\n🚀 开始智能服务器发现...');

      // 1. 获取设备IP
      const deviceIP = await this.getCurrentDeviceIP();
      console.log(`📱 设备IP: ${deviceIP || '未知'}`);

      if (!deviceIP) {
        console.log('⚠️ 无法获取设备IP，使用默认扫描列表');
        // 使用校园网常见段
        return await this.fallbackScan();
      }

      // 2. 生成智能扫描列表
      const candidates = this.generateSmartScanList(deviceIP);
      console.log(`📋 生成 ${candidates.length} 个候选地址`);

      // 3. 并行扫描
      const serverUrl = await this.parallelScan(candidates);

      if (serverUrl) {
        console.log(`🎉 服务器发现成功: ${serverUrl}`);
        return serverUrl;
      }

      // 4. 失败时使用备选方案
      console.log('⚠️ 智能扫描失败，尝试备选方案...');
      return await this.fallbackScan();
    }

    /**
     * 备选扫描方案（校园网常见段）
     */
    private async fallbackScan(): Promise<string | null> {
      const fallbackCandidates = [
        // 校园网常见段
        ...Array.from({ length: 16 }, (_, i) => `http://172.${16 + i}.0.1:5000`),
        // 常见WiFi段
        'http://192.168.1.1:5000',
        'http://192.168.0.1:5000',
        'http://192.168.137.1:5000',
      ];

      return await this.parallelScan(fallbackCandidates);
    }
  }

  ---
  📝 核心代码2：修改API配置

  // llmhomework_Frontend/app/config/api.ts (修改后)

  import { NetworkScanner } from '../services/networkScanner';
  import { IPCache } from '../services/ipCache';

  const BACKEND_PORT = 5000;

  // 🎯 智能服务器发现（替代硬编码IP）
  let discoveredServerUrl: string | null = null;

  export const discoverAndCacheServer = async (): Promise<string> => {
    console.log('🔍 开始服务器发现流程...');

    // 1. 优先使用缓存的成功IP
    const cachedIPs = await IPCache.getRecentSuccessful();
    if (cachedIPs.length > 0) {
      console.log(`💾 尝试缓存IP (${cachedIPs.length}个)`);
      for (const ip of cachedIPs) {
        try {
          const response = await fetch(`${ip}/status`, {
            method: 'GET',
            timeout: 3000
          });
          if (response.ok) {
            console.log(`✅ 缓存IP可用: ${ip}`);
            discoveredServerUrl = ip;
            return ip;
          }
        } catch (e) {
          console.log(`❌ 缓存IP失败: ${ip}`);
        }
      }
    }

    // 2. 智能网段扫描
    console.log('🔍 启动智能网段扫描...');
    const scanner = new NetworkScanner();
    const serverUrl = await scanner.discoverServer();

    if (serverUrl) {
      // 保存到缓存
      await IPCache.save(serverUrl);
      discoveredServerUrl = serverUrl;
      return serverUrl;
    }

    // 3. 失败提示
    throw new Error('无法发现服务器，请确保：\n1. 后端已启动\n2. 设备在校园网内\n3. 防火墙允许访问');
  };

  export const API_CONFIG = {
    get BASE_URL() {
      return discoveredServerUrl || 'http://127.0.0.1:5000';  // 默认值
    },

    // ... 其他配置保持不变 ...

    BACKEND_PORT,
    TIMEOUT: 300000,
    CONNECTION_TIMEOUT: 15000,
    RETRY_COUNT: 3,
    RETRY_DELAY: 5000,
  } as const;

  ---
  📝 核心代码3：修改上传服务

  // llmhomework_Frontend/app/services/apiService.ts (修改部分)

  import { discoverAndCacheServer } from '../config/api';

  const apiService = {
    async uploadImage(image: { uri: string; name: string; type: string }, signal?: AbortSignal) {
      // ... 现有代码 ...

      for (let attempt = 1; attempt <= API_CONFIG.RETRY_COUNT; attempt++) {
        try {
          // 🎯 第一次尝试前，先发现服务器
          if (attempt === 1) {
            console.log('🔍 正在发现服务器...');
            try {
              const serverUrl = await discoverAndCacheServer();
              console.log(`✅ 服务器发现成功: ${serverUrl}`);
              // BASE_URL 会自动更新
            } catch (e) {
              console.error('❌ 服务器发现失败:', e);
              throw new Error('无法连接到服务器，请检查网络和后端状态');
            }
          }

          return await this._performUpload(image, taskId, attempt, signal);

        } catch (error) {
          // ... 现有错误处理 ...

          // 如果网络错误，在重试前重新发现服务器
          if (errorType === 'network' && attempt < API_CONFIG.RETRY_COUNT) {
            console.log('🔄 网络错误，重新发现服务器...');
            try {
              await discoverAndCacheServer();
            } catch (e) {
              console.log('⚠️ 重新发现失败');
            }
          }
        }
      }
    },
  };

  ---
  六、测试计划

  测试场景：

  1. 场景1：首次启动
    - 用户A在172.28.x.x网段
    - 用户B在172.19.x.x网段
    - 两者都应能自动发现服务器
  2. 场景2：IP变化
    - 服务器IP从172.28.140.34变为172.28.150.50
    - 前端应能自动发现新IP
  3. 场景3：网络切换
    - 用户从校园网切换到手机热点
    - 系统应提示无法连接
  4. 场景4：多用户
    - 10个用户同时使用
    - 都应能成功连接

  ---
  七、实施建议

  推荐实施顺序：

  第一周：

  1. ✅ 实现智能网段扫描 (networkScanner.ts)
  2. ✅ 实现IP缓存机制 (ipCache.ts)
  3. ✅ 修改API配置 (api.ts)
  4. ✅ 修改上传服务 (apiService.ts)
  5. ✅ 测试基本功能

  第二周：

  6. ⭐ 实现二维码配置（后端+前端）
  7. ⭐ 添加设置界面（手动配置）
  8. ⭐ 添加连接状态指示器
  9. ✅ 全面测试

  第三周（可选）：

  10. 🔬 实现UDP广播发现
  11. 🔬 多服务器支持
  12. 🔬 性能优化

  ---
  八、预期效果

  用户体验：

  之前：
  1. 下载代码
  2. 找到api.ts文件
  3. 运行ipconfig查看IP
  4. 修改NETWORK_PRESETS数组
  5. 重新编译前端
  6. 启动测试

  之后：
  1. 启动后端
  2. 扫描二维码 OR 直接启动前端
  3. 自动连接，开始使用 ✅

  ---
  这就是完整的解决方案计划！核心是智能网段扫描 + IP缓存 + 二维码配置三管齐下，确保任何用户在校园网内都能即插即用。需要我开始实现代码吗？