
â— ğŸ¯ æ ¡å›­ç½‘è‡ªåŠ¨å‘ç°æœåŠ¡å™¨ - è§£å†³æ–¹æ¡ˆè®¡åˆ’

  ä¸€ã€é—®é¢˜åˆ†æ

  âœ… åç«¯çŠ¶æ€ï¼ˆå·²è§£å†³ï¼‰

  - run.py:183 å·²é…ç½® host='0.0.0.0', port=5000
  - åç«¯ç›‘å¬æ‰€æœ‰ç½‘ç»œæ¥å£ï¼Œä»»ä½•IPéƒ½å¯è®¿é—®
  - æ— éœ€ä¿®æ”¹åç«¯

  âŒ å‰ç«¯é—®é¢˜ï¼ˆéœ€è¦è§£å†³ï¼‰

  1. IPç¡¬ç¼–ç é—®é¢˜ (api.ts:95-106)

  const NETWORK_PRESETS = [
    'http://172.28.140.34:5000',     // å†å²IPï¼Œå¯èƒ½å·²å¤±æ•ˆ
    'http://172.29.15.82:5000',      // å›ºå®šIPï¼Œä¸åŒç”¨æˆ·æ— æ³•ä½¿ç”¨
    'http://172.19.168.76:5000',     // ...
    // æ›´å¤šç¡¬ç¼–ç IP
  ];

  2. ç°æœ‰æ£€æµ‹æœºåˆ¶çš„å±€é™

  - resolveBaseUrl() (apiService.ts:41) åªéå†é¢„è®¾IPåˆ—è¡¨
  - éå†è€—æ—¶é•¿ï¼ˆæ¯ä¸ªIP 15ç§’è¶…æ—¶ï¼‰
  - ç”¨æˆ·åœ¨æ–°IPæ®µæ—¶å®Œå…¨æ— æ³•è¿æ¥

  3. ç”¨æˆ·ç—›ç‚¹

  - æ¯æ¬¡æ ¡å›­ç½‘IPå˜åŒ–éƒ½éœ€è¦ä¿®æ”¹ä»£ç 
  - ä¸åŒç”¨æˆ·éœ€è¦å„è‡ªé…ç½®
  - æ— æ³•åšåˆ°"å³æ’å³ç”¨"

  ---
  äºŒã€è§£å†³æ–¹æ¡ˆè®¾è®¡

  ğŸ¯ æ ¸å¿ƒç›®æ ‡

  è®©ä»»ä½•ç”¨æˆ·åœ¨æ ¡å›­ç½‘å†…ï¼Œä¸è®ºIPåœ°å€ï¼Œéƒ½èƒ½è‡ªåŠ¨å‘ç°å¹¶è¿æ¥åˆ°æœåŠ¡å™¨

  ğŸ“‹ è§£å†³æ–¹æ¡ˆï¼šå¤šå±‚æ¬¡æ™ºèƒ½å‘ç°æœºåˆ¶

  æ–¹æ¡ˆæ¶æ„å›¾

  å‰ç«¯å¯åŠ¨
      â†“
  [1] æ£€æŸ¥ç¼“å­˜çš„æˆåŠŸIP âœ…
      â†“ å¤±è´¥
  [2] æ™ºèƒ½æ ¡å›­ç½‘æ®µæ‰«æ âš¡ (ä¸»è¦æ–¹æ¡ˆ)
      â†“ å¤±è´¥
  [3] UDPå¹¿æ’­æœåŠ¡å‘ç° ğŸ“¡ (å¤‡é€‰æ–¹æ¡ˆ)
      â†“ å¤±è´¥
  [4] æ‰‹åŠ¨è¾“å…¥IP ğŸ”§ (å…œåº•æ–¹æ¡ˆ)

  ---
  ä¸‰ã€è¯¦ç»†å®ç°è®¡åˆ’

  ğŸš€ æ–¹æ¡ˆ1ï¼šæ™ºèƒ½æ ¡å›­ç½‘æ®µæ‰«æ (æ¨èï¼Œä¸»è¦å®ç°)

  åŸç†ï¼š

  - æ·±åœ³å¤§å­¦æ ¡å›­ç½‘IPæ®µï¼š172.16.0.0/12 (172.16.0.0 - 172.31.255.255)
  - è·å–è®¾å¤‡å½“å‰IPï¼Œæ™ºèƒ½æ¨æ–­æœåŠ¡å™¨å¯èƒ½æ‰€åœ¨ç½‘æ®µ
  - å¹¶è¡Œå¿«é€Ÿæ‰«æè¯¥ç½‘æ®µï¼Œæ‰¾åˆ°åç«¯æœåŠ¡å™¨

  å‰ç«¯ä¿®æ”¹ï¼ˆapi.tsï¼‰ï¼š

  æ–°å¢åŠŸèƒ½ï¼š
  1. è·å–è®¾å¤‡å½“å‰IPåœ°å€
  const getCurrentDeviceIP = async () => {
    // ä»Expo Constantsæˆ–ç½‘ç»œæ¥å£è·å–
    // è¿”å›ç±»ä¼¼ "172.28.140.25"
  }
  2. ç”Ÿæˆæ™ºèƒ½æ‰«æåˆ—è¡¨
  const generateSmartScanList = (deviceIP: string) => {
    // å¦‚æœè®¾å¤‡IPæ˜¯ 172.28.140.25
    // ç”Ÿæˆæ‰«æåˆ—è¡¨ï¼š
    // - 172.28.140.x (åŒCæ®µï¼Œä¼˜å…ˆ)
    // - 172.28.x.x (åŒBæ®µ)
    // - 172.x.x.x (åŒAæ®µ)
    // - å¸¸è§ç½‘å…³ï¼š172.28.140.1, 172.28.0.1ç­‰
  }
  3. å¹¶è¡Œå¿«é€Ÿæ‰«æ
  const parallelScan = async (candidates: string[]) => {
    // åŒæ—¶æ£€æµ‹å¤šä¸ªIPï¼ˆå¦‚10ä¸ªå¹¶å‘ï¼‰
    // ä½¿ç”¨çŸ­è¶…æ—¶ï¼ˆ3ç§’ï¼‰
    // ç¬¬ä¸€ä¸ªå“åº”çš„ç«‹å³è¿”å›
  }
  4. æˆåŠŸIPç¼“å­˜
  // ä½¿ç”¨ AsyncStorage ç¼“å­˜æœ€è¿‘æˆåŠŸçš„IP
  // ä¸‹æ¬¡å¯åŠ¨ä¼˜å…ˆå°è¯•

  å®ç°æ–‡ä»¶æ¸…å•ï¼š

  llmhomework_Frontend/app/config/
    â”œâ”€â”€ api.ts (ä¿®æ”¹)
    â””â”€â”€ serverDiscovery.ts (æ–°å¢)

  llmhomework_Frontend/app/services/
    â”œâ”€â”€ apiService.ts (ä¿®æ”¹)
    â””â”€â”€ networkScanner.ts (æ–°å¢)

  ---
  ğŸ“¡ æ–¹æ¡ˆ2ï¼šUDPå¹¿æ’­æœåŠ¡å‘ç° (å¤‡é€‰ï¼Œå¯é€‰å®ç°)

  åŸç†ï¼š

  - åç«¯å¯åŠ¨æ—¶åœ¨å±€åŸŸç½‘å†…å®šæœŸå¹¿æ’­è‡ªå·±çš„IP
  - å‰ç«¯ç›‘å¬å¹¿æ’­ï¼Œè‡ªåŠ¨è·å–åç«¯IP

  åç«¯ä¿®æ”¹ï¼š

  æ–°å¢æ–‡ä»¶ï¼š llmhomework_Backend/app/services/discovery_broadcast.py
  import socket
  import json
  import threading
  import time

  class ServiceBroadcaster:
      def __init__(self, port=5000, broadcast_port=37020):
          self.port = port
          self.broadcast_port = broadcast_port

      def start(self):
          # æ¯5ç§’å¹¿æ’­ä¸€æ¬¡æœåŠ¡å™¨ä¿¡æ¯
          def broadcast_loop():
              sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
              sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)

              while True:
                  message = json.dumps({
                      'service': 'llm-homework-backend',
                      'port': self.port,
                      'ip': get_local_ip()
                  })
                  sock.sendto(message.encode(), ('<broadcast>', self.broadcast_port))
                  time.sleep(5)

          thread = threading.Thread(target=broadcast_loop, daemon=True)
          thread.start()

  åœ¨run.pyä¸­å¯åŠ¨ï¼š
  # run.py æ·»åŠ 
  from app.services.discovery_broadcast import ServiceBroadcaster

  if __name__ == '__main__':
      # å¯åŠ¨æœåŠ¡å‘ç°å¹¿æ’­
      broadcaster = ServiceBroadcaster()
      broadcaster.start()

      app.run(host='0.0.0.0', port=5000, debug=True, threaded=True)

  å‰ç«¯ä¿®æ”¹ï¼š

  æ–°å¢æ–‡ä»¶ï¼š llmhomework_Frontend/app/services/udpDiscovery.ts
  // React Native UDP åº“ç›‘å¬å¹¿æ’­
  import dgram from 'react-native-udp';

  export const discoverServerViaUDP = async (timeout = 10000) => {
    return new Promise((resolve, reject) => {
      const socket = dgram.createSocket('udp4');

      socket.on('message', (msg, rinfo) => {
        const data = JSON.parse(msg.toString());
        if (data.service === 'llm-homework-backend') {
          resolve(`http://${rinfo.address}:${data.port}`);
          socket.close();
        }
      });

      socket.bind(37020);

      setTimeout(() => {
        socket.close();
        reject(new Error('UDP discovery timeout'));
      }, timeout);
    });
  };

  ---
  ğŸ”§ æ–¹æ¡ˆ3ï¼šäºŒç»´ç é…ç½® (ç”¨æˆ·å‹å¥½ï¼Œå¼ºçƒˆæ¨è)

  åŸç†ï¼š

  - åç«¯å¯åŠ¨æ—¶ç”ŸæˆåŒ…å«IPçš„äºŒç»´ç 
  - å‰ç«¯æ‰«æäºŒç»´ç è‡ªåŠ¨é…ç½®

  åç«¯ä¿®æ”¹ï¼š

  å®‰è£…ä¾èµ–ï¼š
  pip install qrcode pillow

  æ–°å¢åŠŸèƒ½ï¼š llmhomework_Backend/app/routes/qr_config.py
  from flask import Blueprint, send_file
  import qrcode
  import io
  import socket

  qr_bp = Blueprint('qr_config', __name__)

  @qr_bp.route('/config/qr', methods=['GET'])
  def get_config_qr():
      """ç”Ÿæˆé…ç½®äºŒç»´ç """
      # è·å–æœ¬æœºIP
      local_ip = socket.gethostbyname(socket.gethostname())

      # æˆ–è€…æ›´å‡†ç¡®çš„IPè·å–
      s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
      s.connect(("8.8.8.8", 80))
      local_ip = s.getsockname()[0]
      s.close()

      # ç”Ÿæˆé…ç½®URL
      config_url = f"http://{local_ip}:5000"

      # ç”ŸæˆäºŒç»´ç 
      qr = qrcode.QRCode(version=1, box_size=10, border=5)
      qr.add_data(config_url)
      qr.make(fit=True)

      img = qr.make_image(fill_color="black", back_color="white")

      # è¿”å›å›¾ç‰‡
      img_io = io.BytesIO()
      img.save(img_io, 'PNG')
      img_io.seek(0)

      return send_file(img_io, mimetype='image/png')

  åœ¨run.pyå¯åŠ¨æ—¶æ˜¾ç¤ºï¼š
  def print_startup_banner():
      # ... ç°æœ‰ä»£ç  ...

      # ç”ŸæˆäºŒç»´ç åˆ°æ§åˆ¶å°ï¼ˆASCIIè‰ºæœ¯ï¼‰
      import qrcode
      local_ip = get_local_ip()
      config_url = f"http://{local_ip}:5000"

      qr = qrcode.QRCode()
      qr.add_data(config_url)
      qr.make()
      qr.print_ascii()  # åœ¨æ§åˆ¶å°æ‰“å°ASCIIäºŒç»´ç 

      print(f"\nğŸ“± æ‰«æäºŒç»´ç é…ç½®å‰ç«¯: {config_url}\n")

  å‰ç«¯ä¿®æ”¹ï¼š

  æ–°å¢å±å¹•ï¼š llmhomework_Frontend/app/screens/QRScannerScreen.tsx
  import { BarCodeScanner } from 'expo-barcode-scanner';

  export const QRScannerScreen = () => {
    const handleBarCodeScanned = ({ data }) => {
      // data = "http://172.28.140.34:5000"
      // ä¿å­˜åˆ° AsyncStorage
      AsyncStorage.setItem('backend_url', data);
      // æ›´æ–°å…¨å±€é…ç½®
      updateApiConfig(data);
    };

    return <BarCodeScanner onBarCodeScanned={handleBarCodeScanned} />;
  };

  ---
  ğŸ’¾ æ–¹æ¡ˆ4ï¼šæˆåŠŸIPæŒä¹…åŒ–ç¼“å­˜

  å®ç°ï¼š

  // llmhomework_Frontend/app/services/ipCache.ts

  import AsyncStorage from '@react-native-async-storage/async-storage';

  export const IPCache = {
    // ä¿å­˜æˆåŠŸçš„IP
    async save(ip: string) {
      const history = await this.getHistory();
      history.unshift({
        ip,
        timestamp: Date.now(),
        success: true
      });
      // åªä¿ç•™æœ€è¿‘10ä¸ª
      await AsyncStorage.setItem('ip_history', JSON.stringify(history.slice(0, 10)));
    },

    // è·å–å†å²è®°å½•
    async getHistory() {
      const data = await AsyncStorage.getItem('ip_history');
      return data ? JSON.parse(data) : [];
    },

    // è·å–æœ€è¿‘æˆåŠŸçš„IPï¼ˆæŒ‰æ—¶é—´æ’åºï¼‰
    async getRecentSuccessful() {
      const history = await this.getHistory();
      return history
        .filter(item => item.success)
        .sort((a, b) => b.timestamp - a.timestamp)
        .map(item => item.ip);
    }
  };

  ---
  å››ã€å®Œæ•´å®ç°è®¡åˆ’ï¼ˆä¼˜å…ˆçº§æ’åºï¼‰

  ğŸ¯ é˜¶æ®µ1ï¼šæ ¸å¿ƒåŠŸèƒ½ (å¿…é¡»å®ç°)

  1.1 æ™ºèƒ½æ ¡å›­ç½‘æ®µæ‰«æ

  - æ–‡ä»¶ï¼š llmhomework_Frontend/app/services/networkScanner.ts
    - è·å–è®¾å¤‡IP
    - ç”Ÿæˆæ™ºèƒ½æ‰«æåˆ—è¡¨
    - å¹¶è¡Œå¿«é€Ÿæ‰«æ
    - è¿”å›ç¬¬ä¸€ä¸ªå¯ç”¨IP

  1.2 IPç¼“å­˜æœºåˆ¶

  - æ–‡ä»¶ï¼š llmhomework_Frontend/app/services/ipCache.ts
    - ä¿å­˜æˆåŠŸIPåˆ°AsyncStorage
    - ä¸‹æ¬¡å¯åŠ¨ä¼˜å…ˆå°è¯•ç¼“å­˜IP

  1.3 ä¿®æ”¹APIé…ç½®

  - æ–‡ä»¶ï¼š llmhomework_Frontend/app/config/api.ts
    - ç§»é™¤ç¡¬ç¼–ç IPåˆ—è¡¨
    - é›†æˆæ™ºèƒ½æ‰«æ
    - ä¼˜å…ˆä½¿ç”¨ç¼“å­˜IP

  1.4 ä¿®æ”¹APIæœåŠ¡

  - æ–‡ä»¶ï¼š llmhomework_Frontend/app/services/apiService.ts
    - åœ¨ä¸Šä¼ å‰è‡ªåŠ¨å‘ç°æœåŠ¡å™¨
    - å¤±è´¥æ—¶è§¦å‘é‡æ–°æ‰«æ

  ---
  â­ é˜¶æ®µ2ï¼šç”¨æˆ·ä½“éªŒä¼˜åŒ– (å¼ºçƒˆæ¨è)

  2.1 äºŒç»´ç é…ç½®

  - åç«¯ï¼š llmhomework_Backend/app/routes/qr_config.py
    - ç”Ÿæˆé…ç½®äºŒç»´ç æ¥å£
    - åœ¨å¯åŠ¨æ¨ªå¹…æ˜¾ç¤ºASCIIäºŒç»´ç 
  - å‰ç«¯ï¼š llmhomework_Frontend/app/screens/QRScannerScreen.tsx
    - äºŒç»´ç æ‰«æåŠŸèƒ½
    - è‡ªåŠ¨é…ç½®åç«¯åœ°å€

  2.2 æ‰‹åŠ¨é…ç½®ç•Œé¢

  - å‰ç«¯ï¼š llmhomework_Frontend/app/screens/SettingsScreen.tsx
    - æ·»åŠ "æ‰‹åŠ¨è¾“å…¥æœåŠ¡å™¨åœ°å€"é€‰é¡¹
    - æ˜¾ç¤ºå½“å‰è¿æ¥çŠ¶æ€
    - æ˜¾ç¤ºIPå†å²è®°å½•

  2.3 è¿æ¥çŠ¶æ€æŒ‡ç¤º

  - å‰ç«¯ï¼š åœ¨ä¸»ç•Œé¢æ·»åŠ ç½‘ç»œçŠ¶æ€æŒ‡ç¤ºå™¨
    - æ˜¾ç¤ºå½“å‰è¿æ¥çš„æœåŠ¡å™¨IP
    - æ˜¾ç¤ºè¿æ¥è´¨é‡ï¼ˆå»¶è¿Ÿï¼‰
    - ä¸€é”®é‡æ–°æ‰«ææŒ‰é’®

  ---
  ğŸ”¬ é˜¶æ®µ3ï¼šé«˜çº§åŠŸèƒ½ (å¯é€‰)

  3.1 UDPå¹¿æ’­å‘ç°

  - åç«¯ï¼š llmhomework_Backend/app/services/discovery_broadcast.py
  - å‰ç«¯ï¼š llmhomework_Frontend/app/services/udpDiscovery.ts
  - ä¾èµ–ï¼š npm install react-native-udp

  3.2 å¤šæœåŠ¡å™¨æ”¯æŒ

  - æ”¯æŒåŒæ—¶å‘ç°å¤šä¸ªåç«¯æœåŠ¡å™¨
  - è‡ªåŠ¨é€‰æ‹©å»¶è¿Ÿæœ€ä½çš„æœåŠ¡å™¨
  - è´Ÿè½½å‡è¡¡

  ---
  äº”ã€æ ¸å¿ƒä»£ç å®ç°é¢„è§ˆ

  ğŸ“ æ ¸å¿ƒä»£ç 1ï¼šæ™ºèƒ½ç½‘æ®µæ‰«æ

  // llmhomework_Frontend/app/services/networkScanner.ts

  import { Platform } from 'react-native';
  import NetInfo from '@react-native-community/netinfo';

  export class NetworkScanner {
    private readonly BACKEND_PORT = 5000;
    private readonly SCAN_TIMEOUT = 3000;  // å•ä¸ªIPæ‰«æè¶…æ—¶3ç§’
    private readonly PARALLEL_SCANS = 10;   // åŒæ—¶æ‰«æ10ä¸ªIP

    /**
     * è·å–è®¾å¤‡å½“å‰IPåœ°å€
     */
    async getCurrentDeviceIP(): Promise<string | null> {
      try {
        const netInfo = await NetInfo.fetch();
        // React Native NetInfo å¯èƒ½éœ€è¦åŸç”Ÿæ¨¡å—æ”¯æŒ
        // å¤‡é€‰æ–¹æ¡ˆï¼šä»Expo Constantsè·å–
        return netInfo.details?.ipAddress || null;
      } catch (error) {
        console.error('è·å–è®¾å¤‡IPå¤±è´¥:', error);
        return null;
      }
    }

    /**
     * æ ¹æ®è®¾å¤‡IPç”Ÿæˆæ™ºèƒ½æ‰«æåˆ—è¡¨
     */
    generateSmartScanList(deviceIP: string): string[] {
      const candidates: string[] = [];

      // è§£æIP (ä¾‹å¦‚: 172.28.140.25)
      const parts = deviceIP.split('.');
      if (parts.length !== 4) return [];

      const [a, b, c, d] = parts;

      // 1. åŒCæ®µæ‰«æ (172.28.140.x) - æœ€ä¼˜å…ˆ
      // ä¼˜å…ˆæ‰«æå¸¸è§æœåŠ¡å™¨IP
      const commonHosts = [1, 2, 10, 100, 254];  // å¸¸è§ç½‘å…³/æœåŠ¡å™¨IP
      for (const host of commonHosts) {
        candidates.push(`http://${a}.${b}.${c}.${host}:${this.BACKEND_PORT}`);
      }

      // æ‰«æé‚»è¿‘IP
      const currentHost = parseInt(d);
      for (let offset = 1; offset <= 20; offset++) {
        const host1 = currentHost - offset;
        const host2 = currentHost + offset;
        if (host1 > 0) candidates.push(`http://${a}.${b}.${c}.${host1}:${this.BACKEND_PORT}`);
        if (host2 < 255) candidates.push(`http://${a}.${b}.${c}.${host2}:${this.BACKEND_PORT}`);
      }

      // 2. åŒBæ®µä¸åŒCæ®µ (172.28.x.1)
      for (let c_new = 0; c_new < 256; c_new += 10) {
        if (c_new.toString() !== c) {
          candidates.push(`http://${a}.${b}.${c_new}.1:${this.BACKEND_PORT}`);
        }
      }

      // 3. æ ¡å›­ç½‘å…¶ä»–å¸¸è§æ®µ (172.16-31.x.x)
      for (let b_new = 16; b_new <= 31; b_new++) {
        if (b_new.toString() !== b) {
          candidates.push(`http://${a}.${b_new}.0.1:${this.BACKEND_PORT}`);
        }
      }

      // å»é‡
      return Array.from(new Set(candidates));
    }

    /**
     * å¹¶è¡Œå¿«é€Ÿæ‰«æ
     */
    async parallelScan(candidates: string[]): Promise<string | null> {
      console.log(`ğŸ” å¼€å§‹å¹¶è¡Œæ‰«æ ${candidates.length} ä¸ªå€™é€‰åœ°å€...`);

      // åˆ†æ‰¹å¹¶è¡Œæ‰«æ
      for (let i = 0; i < candidates.length; i += this.PARALLEL_SCANS) {
        const batch = candidates.slice(i, i + this.PARALLEL_SCANS);
        console.log(`ğŸ“¡ æ‰«ææ‰¹æ¬¡ ${Math.floor(i / this.PARALLEL_SCANS) + 1}: ${batch.length} ä¸ªåœ°å€`);

        const result = await this.scanBatch(batch);
        if (result) {
          console.log(`âœ… æ‰¾åˆ°æœåŠ¡å™¨: ${result}`);
          return result;
        }
      }

      console.log('âŒ æ‰€æœ‰å€™é€‰åœ°å€æ‰«æå®Œæ¯•ï¼Œæœªæ‰¾åˆ°æœåŠ¡å™¨');
      return null;
    }

    /**
     * æ‰«æä¸€æ‰¹IP
     */
    private async scanBatch(urls: string[]): Promise<string | null> {
      const promises = urls.map(url => this.checkServer(url));

      // ä½¿ç”¨ Promise.race è¿”å›ç¬¬ä¸€ä¸ªæˆåŠŸçš„
      try {
        const result = await Promise.race(
          promises.map(p => p.then(url => ({ success: true, url })))
        );
        if (result.success) {
          return result.url;
        }
      } catch (error) {
        // æ‰€æœ‰éƒ½å¤±è´¥
      }

      return null;
    }

    /**
     * æ£€æŸ¥å•ä¸ªæœåŠ¡å™¨
     */
    private async checkServer(url: string): Promise<string | null> {
      try {
        const controller = new AbortController();
        const timeout = setTimeout(() => controller.abort(), this.SCAN_TIMEOUT);

        const response = await fetch(`${url}/status`, {
          method: 'GET',
          signal: controller.signal,
          headers: {
            'Cache-Control': 'no-cache',
          },
        });

        clearTimeout(timeout);

        if (response.ok) {
          console.log(`âœ… æœåŠ¡å™¨å“åº”: ${url}`);
          return url;
        }
      } catch (error) {
        // é™é»˜å¤±è´¥ï¼Œç»§ç»­ä¸‹ä¸€ä¸ª
      }

      return null;
    }

    /**
     * ä¸»å…¥å£ï¼šæ™ºèƒ½å‘ç°æœåŠ¡å™¨
     */
    async discoverServer(): Promise<string | null> {
      console.log('\nğŸš€ å¼€å§‹æ™ºèƒ½æœåŠ¡å™¨å‘ç°...');

      // 1. è·å–è®¾å¤‡IP
      const deviceIP = await this.getCurrentDeviceIP();
      console.log(`ğŸ“± è®¾å¤‡IP: ${deviceIP || 'æœªçŸ¥'}`);

      if (!deviceIP) {
        console.log('âš ï¸ æ— æ³•è·å–è®¾å¤‡IPï¼Œä½¿ç”¨é»˜è®¤æ‰«æåˆ—è¡¨');
        // ä½¿ç”¨æ ¡å›­ç½‘å¸¸è§æ®µ
        return await this.fallbackScan();
      }

      // 2. ç”Ÿæˆæ™ºèƒ½æ‰«æåˆ—è¡¨
      const candidates = this.generateSmartScanList(deviceIP);
      console.log(`ğŸ“‹ ç”Ÿæˆ ${candidates.length} ä¸ªå€™é€‰åœ°å€`);

      // 3. å¹¶è¡Œæ‰«æ
      const serverUrl = await this.parallelScan(candidates);

      if (serverUrl) {
        console.log(`ğŸ‰ æœåŠ¡å™¨å‘ç°æˆåŠŸ: ${serverUrl}`);
        return serverUrl;
      }

      // 4. å¤±è´¥æ—¶ä½¿ç”¨å¤‡é€‰æ–¹æ¡ˆ
      console.log('âš ï¸ æ™ºèƒ½æ‰«æå¤±è´¥ï¼Œå°è¯•å¤‡é€‰æ–¹æ¡ˆ...');
      return await this.fallbackScan();
    }

    /**
     * å¤‡é€‰æ‰«ææ–¹æ¡ˆï¼ˆæ ¡å›­ç½‘å¸¸è§æ®µï¼‰
     */
    private async fallbackScan(): Promise<string | null> {
      const fallbackCandidates = [
        // æ ¡å›­ç½‘å¸¸è§æ®µ
        ...Array.from({ length: 16 }, (_, i) => `http://172.${16 + i}.0.1:5000`),
        // å¸¸è§WiFiæ®µ
        'http://192.168.1.1:5000',
        'http://192.168.0.1:5000',
        'http://192.168.137.1:5000',
      ];

      return await this.parallelScan(fallbackCandidates);
    }
  }

  ---
  ğŸ“ æ ¸å¿ƒä»£ç 2ï¼šä¿®æ”¹APIé…ç½®

  // llmhomework_Frontend/app/config/api.ts (ä¿®æ”¹å)

  import { NetworkScanner } from '../services/networkScanner';
  import { IPCache } from '../services/ipCache';

  const BACKEND_PORT = 5000;

  // ğŸ¯ æ™ºèƒ½æœåŠ¡å™¨å‘ç°ï¼ˆæ›¿ä»£ç¡¬ç¼–ç IPï¼‰
  let discoveredServerUrl: string | null = null;

  export const discoverAndCacheServer = async (): Promise<string> => {
    console.log('ğŸ” å¼€å§‹æœåŠ¡å™¨å‘ç°æµç¨‹...');

    // 1. ä¼˜å…ˆä½¿ç”¨ç¼“å­˜çš„æˆåŠŸIP
    const cachedIPs = await IPCache.getRecentSuccessful();
    if (cachedIPs.length > 0) {
      console.log(`ğŸ’¾ å°è¯•ç¼“å­˜IP (${cachedIPs.length}ä¸ª)`);
      for (const ip of cachedIPs) {
        try {
          const response = await fetch(`${ip}/status`, {
            method: 'GET',
            timeout: 3000
          });
          if (response.ok) {
            console.log(`âœ… ç¼“å­˜IPå¯ç”¨: ${ip}`);
            discoveredServerUrl = ip;
            return ip;
          }
        } catch (e) {
          console.log(`âŒ ç¼“å­˜IPå¤±è´¥: ${ip}`);
        }
      }
    }

    // 2. æ™ºèƒ½ç½‘æ®µæ‰«æ
    console.log('ğŸ” å¯åŠ¨æ™ºèƒ½ç½‘æ®µæ‰«æ...');
    const scanner = new NetworkScanner();
    const serverUrl = await scanner.discoverServer();

    if (serverUrl) {
      // ä¿å­˜åˆ°ç¼“å­˜
      await IPCache.save(serverUrl);
      discoveredServerUrl = serverUrl;
      return serverUrl;
    }

    // 3. å¤±è´¥æç¤º
    throw new Error('æ— æ³•å‘ç°æœåŠ¡å™¨ï¼Œè¯·ç¡®ä¿ï¼š\n1. åç«¯å·²å¯åŠ¨\n2. è®¾å¤‡åœ¨æ ¡å›­ç½‘å†…\n3. é˜²ç«å¢™å…è®¸è®¿é—®');
  };

  export const API_CONFIG = {
    get BASE_URL() {
      return discoveredServerUrl || 'http://127.0.0.1:5000';  // é»˜è®¤å€¼
    },

    // ... å…¶ä»–é…ç½®ä¿æŒä¸å˜ ...

    BACKEND_PORT,
    TIMEOUT: 300000,
    CONNECTION_TIMEOUT: 15000,
    RETRY_COUNT: 3,
    RETRY_DELAY: 5000,
  } as const;

  ---
  ğŸ“ æ ¸å¿ƒä»£ç 3ï¼šä¿®æ”¹ä¸Šä¼ æœåŠ¡

  // llmhomework_Frontend/app/services/apiService.ts (ä¿®æ”¹éƒ¨åˆ†)

  import { discoverAndCacheServer } from '../config/api';

  const apiService = {
    async uploadImage(image: { uri: string; name: string; type: string }, signal?: AbortSignal) {
      // ... ç°æœ‰ä»£ç  ...

      for (let attempt = 1; attempt <= API_CONFIG.RETRY_COUNT; attempt++) {
        try {
          // ğŸ¯ ç¬¬ä¸€æ¬¡å°è¯•å‰ï¼Œå…ˆå‘ç°æœåŠ¡å™¨
          if (attempt === 1) {
            console.log('ğŸ” æ­£åœ¨å‘ç°æœåŠ¡å™¨...');
            try {
              const serverUrl = await discoverAndCacheServer();
              console.log(`âœ… æœåŠ¡å™¨å‘ç°æˆåŠŸ: ${serverUrl}`);
              // BASE_URL ä¼šè‡ªåŠ¨æ›´æ–°
            } catch (e) {
              console.error('âŒ æœåŠ¡å™¨å‘ç°å¤±è´¥:', e);
              throw new Error('æ— æ³•è¿æ¥åˆ°æœåŠ¡å™¨ï¼Œè¯·æ£€æŸ¥ç½‘ç»œå’Œåç«¯çŠ¶æ€');
            }
          }

          return await this._performUpload(image, taskId, attempt, signal);

        } catch (error) {
          // ... ç°æœ‰é”™è¯¯å¤„ç† ...

          // å¦‚æœç½‘ç»œé”™è¯¯ï¼Œåœ¨é‡è¯•å‰é‡æ–°å‘ç°æœåŠ¡å™¨
          if (errorType === 'network' && attempt < API_CONFIG.RETRY_COUNT) {
            console.log('ğŸ”„ ç½‘ç»œé”™è¯¯ï¼Œé‡æ–°å‘ç°æœåŠ¡å™¨...');
            try {
              await discoverAndCacheServer();
            } catch (e) {
              console.log('âš ï¸ é‡æ–°å‘ç°å¤±è´¥');
            }
          }
        }
      }
    },
  };

  ---
  å…­ã€æµ‹è¯•è®¡åˆ’

  æµ‹è¯•åœºæ™¯ï¼š

  1. åœºæ™¯1ï¼šé¦–æ¬¡å¯åŠ¨
    - ç”¨æˆ·Aåœ¨172.28.x.xç½‘æ®µ
    - ç”¨æˆ·Båœ¨172.19.x.xç½‘æ®µ
    - ä¸¤è€…éƒ½åº”èƒ½è‡ªåŠ¨å‘ç°æœåŠ¡å™¨
  2. åœºæ™¯2ï¼šIPå˜åŒ–
    - æœåŠ¡å™¨IPä»172.28.140.34å˜ä¸º172.28.150.50
    - å‰ç«¯åº”èƒ½è‡ªåŠ¨å‘ç°æ–°IP
  3. åœºæ™¯3ï¼šç½‘ç»œåˆ‡æ¢
    - ç”¨æˆ·ä»æ ¡å›­ç½‘åˆ‡æ¢åˆ°æ‰‹æœºçƒ­ç‚¹
    - ç³»ç»Ÿåº”æç¤ºæ— æ³•è¿æ¥
  4. åœºæ™¯4ï¼šå¤šç”¨æˆ·
    - 10ä¸ªç”¨æˆ·åŒæ—¶ä½¿ç”¨
    - éƒ½åº”èƒ½æˆåŠŸè¿æ¥

  ---
  ä¸ƒã€å®æ–½å»ºè®®

  æ¨èå®æ–½é¡ºåºï¼š

  ç¬¬ä¸€å‘¨ï¼š

  1. âœ… å®ç°æ™ºèƒ½ç½‘æ®µæ‰«æ (networkScanner.ts)
  2. âœ… å®ç°IPç¼“å­˜æœºåˆ¶ (ipCache.ts)
  3. âœ… ä¿®æ”¹APIé…ç½® (api.ts)
  4. âœ… ä¿®æ”¹ä¸Šä¼ æœåŠ¡ (apiService.ts)
  5. âœ… æµ‹è¯•åŸºæœ¬åŠŸèƒ½

  ç¬¬äºŒå‘¨ï¼š

  6. â­ å®ç°äºŒç»´ç é…ç½®ï¼ˆåç«¯+å‰ç«¯ï¼‰
  7. â­ æ·»åŠ è®¾ç½®ç•Œé¢ï¼ˆæ‰‹åŠ¨é…ç½®ï¼‰
  8. â­ æ·»åŠ è¿æ¥çŠ¶æ€æŒ‡ç¤ºå™¨
  9. âœ… å…¨é¢æµ‹è¯•

  ç¬¬ä¸‰å‘¨ï¼ˆå¯é€‰ï¼‰ï¼š

  10. ğŸ”¬ å®ç°UDPå¹¿æ’­å‘ç°
  11. ğŸ”¬ å¤šæœåŠ¡å™¨æ”¯æŒ
  12. ğŸ”¬ æ€§èƒ½ä¼˜åŒ–

  ---
  å…«ã€é¢„æœŸæ•ˆæœ

  ç”¨æˆ·ä½“éªŒï¼š

  ä¹‹å‰ï¼š
  1. ä¸‹è½½ä»£ç 
  2. æ‰¾åˆ°api.tsæ–‡ä»¶
  3. è¿è¡ŒipconfigæŸ¥çœ‹IP
  4. ä¿®æ”¹NETWORK_PRESETSæ•°ç»„
  5. é‡æ–°ç¼–è¯‘å‰ç«¯
  6. å¯åŠ¨æµ‹è¯•

  ä¹‹åï¼š
  1. å¯åŠ¨åç«¯
  2. æ‰«æäºŒç»´ç  OR ç›´æ¥å¯åŠ¨å‰ç«¯
  3. è‡ªåŠ¨è¿æ¥ï¼Œå¼€å§‹ä½¿ç”¨ âœ…

  ---
  è¿™å°±æ˜¯å®Œæ•´çš„è§£å†³æ–¹æ¡ˆè®¡åˆ’ï¼æ ¸å¿ƒæ˜¯æ™ºèƒ½ç½‘æ®µæ‰«æ + IPç¼“å­˜ + äºŒç»´ç é…ç½®ä¸‰ç®¡é½ä¸‹ï¼Œç¡®ä¿ä»»ä½•ç”¨æˆ·åœ¨æ ¡å›­ç½‘å†…éƒ½èƒ½å³æ’å³ç”¨ã€‚éœ€è¦æˆ‘å¼€å§‹å®ç°ä»£ç å—ï¼Ÿ